'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var UploadClientError = /** @class */ (function (_super) {
    __extends(UploadClientError, _super);
    function UploadClientError(message, code, request, response, headers) {
        var _this = _super.call(this) || this;
        _this.name = 'UploadClientError';
        _this.message = message;
        _this.code = code;
        _this.request = request;
        _this.response = response;
        _this.headers = headers;
        Object.setPrototypeOf(_this, UploadClientError.prototype);
        return _this;
    }
    return UploadClientError;
}(Error));
var cancelError = function (message) {
    if (message === void 0) { message = 'Request canceled'; }
    var error = new UploadClientError(message);
    error.isCancel = true;
    return error;
};

var onCancel = function (signal, callback) {
    if (signal) {
        if (signal.aborted) {
            Promise.resolve().then(callback);
        }
        else {
            signal.addEventListener('abort', function () { return callback(); }, { once: true });
        }
    }
};

var request = function (_a) {
    var method = _a.method, url = _a.url, data = _a.data, _b = _a.headers, headers = _b === void 0 ? {} : _b, signal = _a.signal, onProgress = _a.onProgress;
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        var requestMethod = (method === null || method === void 0 ? void 0 : method.toUpperCase()) || 'GET';
        var aborted = false;
        xhr.open(requestMethod, url);
        if (headers) {
            Object.entries(headers).forEach(function (entry) {
                var key = entry[0], value = entry[1];
                typeof value !== 'undefined' &&
                    !Array.isArray(value) &&
                    xhr.setRequestHeader(key, value);
            });
        }
        xhr.responseType = 'text';
        onCancel(signal, function () {
            aborted = true;
            xhr.abort();
            reject(cancelError());
        });
        xhr.onload = function () {
            if (xhr.status != 200) {
                // analyze HTTP status of the response
                reject(new Error("Error " + xhr.status + ": " + xhr.statusText)); // e.g. 404: Not Found
            }
            else {
                var request_1 = {
                    method: requestMethod,
                    url: url,
                    data: data,
                    headers: headers || undefined,
                    signal: signal,
                    onProgress: onProgress
                };
                // Convert the header string into an array
                // of individual headers
                var headersArray = xhr
                    .getAllResponseHeaders()
                    .trim()
                    .split(/[\r\n]+/);
                // Create a map of header names to values
                var responseHeaders_1 = {};
                headersArray.forEach(function (line) {
                    var parts = line.split(': ');
                    var header = parts.shift();
                    var value = parts.join(': ');
                    if (header && typeof header !== 'undefined') {
                        responseHeaders_1[header] = value;
                    }
                });
                var responseData = xhr.response;
                var responseStatus = xhr.status;
                resolve({
                    request: request_1,
                    data: responseData,
                    headers: responseHeaders_1,
                    status: responseStatus
                });
            }
        };
        xhr.onerror = function () {
            if (aborted)
                return;
            // only triggers if the request couldn't be made at all
            reject(new Error('Network error'));
        };
        if (onProgress && typeof onProgress === 'function') {
            xhr.upload.onprogress = function (event) {
                onProgress({ value: event.loaded / event.total });
            };
        }
        if (data) {
            xhr.send(data);
        }
        else {
            xhr.send();
        }
    });
};

function identity(obj) {
    return obj;
}

var transformFile = identity;
var getFormData = (function () { return new FormData(); });

var isFileTuple = function (tuple) {
    return tuple[0] === 'file';
};
function buildFormData(body) {
    var formData = getFormData();
    var _loop_1 = function (tuple) {
        if (Array.isArray(tuple[1])) {
            // refactor this
            tuple[1].forEach(function (val) { return val && formData.append(tuple[0] + '[]', "" + val); });
        }
        else if (isFileTuple(tuple)) {
            var name_1 = tuple[2];
            var file = transformFile(tuple[1]); // lgtm[js/superfluous-trailing-arguments]
            formData.append(tuple[0], file, name_1);
        }
        else if (tuple[1] != null) {
            formData.append(tuple[0], "" + tuple[1]);
        }
    };
    for (var _i = 0, body_1 = body; _i < body_1.length; _i++) {
        var tuple = body_1[_i];
        _loop_1(tuple);
    }
    return formData;
}

var serializePair = function (key, value) {
    return typeof value !== 'undefined' ? key + "=" + encodeURIComponent(value) : null;
};
var createQuery = function (query) {
    return Object.entries(query)
        .reduce(function (params, _a) {
        var key = _a[0], value = _a[1];
        return params.concat(Array.isArray(value)
            ? value.map(function (value) { return serializePair(key + "[]", value); })
            : serializePair(key, value));
    }, [])
        .filter(function (x) { return !!x; })
        .join('&');
};
var getUrl = function (base, path, query) {
    return [
        base,
        path,
        query && Object.keys(query).length > 0 ? '?' : '',
        query && createQuery(query)
    ]
        .filter(Boolean)
        .join('');
};

/*
  Settings for future support:
  parallelDirectUploads: 10,
 */
var defaultSettings = {
    baseCDN: 'https://ucarecdn.com',
    baseURL: 'https://upload.uploadcare.com',
    maxContentLength: 50 * 1024 * 1024,
    retryThrottledRequestMaxTimes: 1,
    multipartMinFileSize: 25 * 1024 * 1024,
    multipartChunkSize: 5 * 1024 * 1024,
    multipartMinLastPartSize: 1024 * 1024,
    maxConcurrentRequests: 4,
    multipartMaxAttempts: 3,
    pollingTimeoutMilliseconds: 10000,
    pusherKey: '79ae88bd931ea68464d9'
};
var defaultContentType = 'application/octet-stream';
var defaultFilename = 'original';

var version = '2.2.0';

/**
 * Returns User Agent based on version and settings.
 */
function getUserAgent(_a) {
    var _b = _a === void 0 ? {} : _a, userAgent = _b.userAgent, _c = _b.publicKey, publicKey = _c === void 0 ? '' : _c, _d = _b.integration, integration = _d === void 0 ? '' : _d;
    var libraryName = 'UploadcareUploadClient';
    var libraryVersion = version;
    var languageName = 'JavaScript';
    if (typeof userAgent === 'string') {
        return userAgent;
    }
    if (typeof userAgent === 'function') {
        return userAgent({
            publicKey: publicKey,
            libraryName: libraryName,
            libraryVersion: libraryVersion,
            languageName: languageName,
            integration: integration
        });
    }
    var mainInfo = [libraryName, libraryVersion, publicKey]
        .filter(Boolean)
        .join('/');
    var additionInfo = [languageName, integration].filter(Boolean).join('; ');
    return mainInfo + " (" + additionInfo + ")";
}

var SEPARATOR = /\W|_/g;
/**
 * Transforms a string to camelCased.
 */
function camelize(text) {
    return text
        .split(SEPARATOR)
        .map(function (word, index) {
        return word.charAt(0)[index > 0 ? 'toUpperCase' : 'toLowerCase']() +
            word.slice(1);
    })
        .join('');
}
/**
 * Transforms keys of an object to camelCased recursively.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function camelizeKeys(source) {
    if (!source || typeof source !== 'object') {
        return source;
    }
    return Object.keys(source).reduce(function (accumulator, key) {
        accumulator[camelize(key)] =
            typeof source[key] === 'object' ? camelizeKeys(source[key]) : source[key];
        return accumulator;
    }, {});
}

/**
 * setTimeout as Promise.
 *
 * @param {number} ms Timeout in milliseconds.
 */
var delay = function (ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
};

var defaultOptions = {
    factor: 2,
    time: 100
};
function retrier(fn, options) {
    if (options === void 0) { options = defaultOptions; }
    var attempts = 0;
    function runAttempt(fn) {
        var defaultDelayTime = Math.round(options.time * Math.pow(options.factor, attempts));
        var retry = function (ms) {
            return delay(ms !== null && ms !== void 0 ? ms : defaultDelayTime).then(function () {
                attempts += 1;
                return runAttempt(fn);
            });
        };
        return fn({
            attempt: attempts,
            retry: retry
        });
    }
    return runAttempt(fn);
}

var REQUEST_WAS_THROTTLED_CODE = 'RequestThrottledError';
var DEFAULT_RETRY_AFTER_TIMEOUT = 15000;
function getTimeoutFromThrottledRequest(error) {
    var headers = (error || {}).headers;
    return ((headers &&
        Number.parseInt(headers['x-throttle-wait-seconds']) * 1000) ||
        DEFAULT_RETRY_AFTER_TIMEOUT);
}
function retryIfThrottled(fn, retryThrottledMaxTimes) {
    return retrier(function (_a) {
        var attempt = _a.attempt, retry = _a.retry;
        return fn().catch(function (error) {
            if ('response' in error &&
                (error === null || error === void 0 ? void 0 : error.code) === REQUEST_WAS_THROTTLED_CODE &&
                attempt < retryThrottledMaxTimes) {
                return retry(getTimeoutFromThrottledRequest(error));
            }
            throw error;
        });
    });
}

/**
 * Performs file uploading request to Uploadcare Upload API.
 * Can be canceled and has progress.
 */
function base(file, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, _c = _a.source, source = _c === void 0 ? 'local' : _c, integration = _a.integration, userAgent = _a.userAgent, _d = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _d === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _d;
    return retryIfThrottled(function () {
        var _a;
        return request({
            method: 'POST',
            url: getUrl(baseURL, '/base/', {
                jsonerrors: 1
            }),
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            data: buildFormData([
                ['file', file, (_a = fileName !== null && fileName !== void 0 ? fileName : file.name) !== null && _a !== void 0 ? _a : defaultFilename],
                ['UPLOADCARE_PUB_KEY', publicKey],
                [
                    'UPLOADCARE_STORE',
                    typeof store === 'undefined' ? 'auto' : store ? 1 : 0
                ],
                ['signature', secureSignature],
                ['expire', secureExpire],
                ['source', source]
            ]),
            signal: signal,
            onProgress: onProgress
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

var TypeEnum;
(function (TypeEnum) {
    TypeEnum["Token"] = "token";
    TypeEnum["FileInfo"] = "file_info";
})(TypeEnum || (TypeEnum = {}));
/**
 * Uploading files from URL.
 */
function fromUrl(sourceUrl, _a) {
    var publicKey = _a.publicKey, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, store = _a.store, fileName = _a.fileName, checkForUrlDuplicates = _a.checkForUrlDuplicates, saveUrlForRecurrentUploads = _a.saveUrlForRecurrentUploads, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, _c = _a.source, source = _c === void 0 ? 'url' : _c, signal = _a.signal, integration = _a.integration, userAgent = _a.userAgent, _d = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _d === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _d;
    return retryIfThrottled(function () {
        return request({
            method: 'POST',
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            url: getUrl(baseURL, '/from_url/', {
                jsonerrors: 1,
                pub_key: publicKey,
                source_url: sourceUrl,
                store: typeof store === 'undefined' ? 'auto' : store ? 1 : undefined,
                filename: fileName,
                check_URL_duplicates: checkForUrlDuplicates ? 1 : undefined,
                save_URL_duplicates: saveUrlForRecurrentUploads ? 1 : undefined,
                signature: secureSignature,
                expire: secureExpire,
                source: source
            }),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

var Status;
(function (Status) {
    Status["Unknown"] = "unknown";
    Status["Waiting"] = "waiting";
    Status["Progress"] = "progress";
    Status["Error"] = "error";
    Status["Success"] = "success";
})(Status || (Status = {}));
var isErrorResponse = function (response) {
    return 'status' in response && response.status === Status.Error;
};
/**
 * Checking upload status and working with file tokens.
 */
function fromUrlStatus(token, _a) {
    var _b = _a === void 0 ? {} : _a, publicKey = _b.publicKey, _c = _b.baseURL, baseURL = _c === void 0 ? defaultSettings.baseURL : _c, signal = _b.signal, integration = _b.integration, userAgent = _b.userAgent, _d = _b.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _d === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _d;
    return retryIfThrottled(function () {
        return request({
            method: 'GET',
            headers: publicKey
                ? {
                    'X-UC-User-Agent': getUserAgent({
                        publicKey: publicKey,
                        integration: integration,
                        userAgent: userAgent
                    })
                }
                : undefined,
            url: getUrl(baseURL, '/from_url/status/', {
                jsonerrors: 1,
                token: token
            }),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response && !isErrorResponse(response)) {
                throw new UploadClientError(response.error.content, undefined, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

/**
 * Create files group.
 */
function group(uuids, _a) {
    var publicKey = _a.publicKey, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, jsonpCallback = _a.jsonpCallback, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, signal = _a.signal, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, _c = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _c === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _c;
    return retryIfThrottled(function () {
        return request({
            method: 'POST',
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            url: getUrl(baseURL, '/group/', {
                jsonerrors: 1,
                pub_key: publicKey,
                files: uuids,
                callback: jsonpCallback,
                signature: secureSignature,
                expire: secureExpire,
                source: source
            }),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

/**
 * Get info about group.
 */
function groupInfo(id, _a) {
    var publicKey = _a.publicKey, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, signal = _a.signal, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, _c = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _c === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _c;
    return retryIfThrottled(function () {
        return request({
            method: 'GET',
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            url: getUrl(baseURL, '/group/info/', {
                jsonerrors: 1,
                pub_key: publicKey,
                group_id: id,
                source: source
            }),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

/**
 * Returns a JSON dictionary holding file info.
 */
function info(uuid, _a) {
    var publicKey = _a.publicKey, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, signal = _a.signal, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, _c = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _c === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _c;
    return retryIfThrottled(function () {
        return request({
            method: 'GET',
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            url: getUrl(baseURL, '/info/', {
                jsonerrors: 1,
                pub_key: publicKey,
                file_id: uuid,
                source: source
            }),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

/**
 * Start multipart uploading.
 */
function multipartStart(size, _a) {
    var publicKey = _a.publicKey, contentType = _a.contentType, fileName = _a.fileName, _b = _a.multipartChunkSize, multipartChunkSize = _b === void 0 ? defaultSettings.multipartChunkSize : _b, _c = _a.baseURL, baseURL = _c === void 0 ? '' : _c, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, _d = _a.source, source = _d === void 0 ? 'local' : _d, integration = _a.integration, userAgent = _a.userAgent, _e = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _e === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _e;
    return retryIfThrottled(function () {
        return request({
            method: 'POST',
            url: getUrl(baseURL, '/multipart/start/', { jsonerrors: 1 }),
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            data: buildFormData([
                ['filename', fileName !== null && fileName !== void 0 ? fileName : defaultFilename],
                ['size', size],
                ['content_type', contentType !== null && contentType !== void 0 ? contentType : defaultContentType],
                ['part_size', multipartChunkSize],
                ['UPLOADCARE_STORE', store ? '' : 'auto'],
                ['UPLOADCARE_PUB_KEY', publicKey],
                ['signature', secureSignature],
                ['expire', secureExpire],
                ['source', source]
            ]),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                // convert to array
                response.parts = Object.keys(response.parts).map(function (key) { return response.parts[key]; });
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

/**
 * Complete multipart uploading.
 */
function multipartUpload(part, url, _a) {
    var signal = _a.signal, onProgress = _a.onProgress;
    return request({
        method: 'PUT',
        url: url,
        data: part,
        onProgress: onProgress,
        signal: signal
    })
        .then(function (result) {
        // hack for node ¯\_(ツ)_/¯
        if (onProgress)
            onProgress({ value: 1 });
        return result;
    })
        .then(function (_a) {
        var status = _a.status;
        return ({ code: status });
    });
}

/**
 * Complete multipart uploading.
 */
function multipartComplete(uuid, _a) {
    var publicKey = _a.publicKey, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, _c = _a.source, source = _c === void 0 ? 'local' : _c, signal = _a.signal, integration = _a.integration, userAgent = _a.userAgent, _d = _a.retryThrottledRequestMaxTimes, retryThrottledRequestMaxTimes = _d === void 0 ? defaultSettings.retryThrottledRequestMaxTimes : _d;
    return retryIfThrottled(function () {
        return request({
            method: 'POST',
            url: getUrl(baseURL, '/multipart/complete/', { jsonerrors: 1 }),
            headers: {
                'X-UC-User-Agent': getUserAgent({ publicKey: publicKey, integration: integration, userAgent: userAgent })
            },
            data: buildFormData([
                ['uuid', uuid],
                ['UPLOADCARE_PUB_KEY', publicKey],
                ['source', source]
            ]),
            signal: signal
        }).then(function (_a) {
            var data = _a.data, headers = _a.headers, request = _a.request;
            var response = camelizeKeys(JSON.parse(data));
            if ('error' in response) {
                throw new UploadClientError(response.error.content, response.error.errorCode, request, response, headers);
            }
            else {
                return response;
            }
        });
    }, retryThrottledRequestMaxTimes);
}

var UploadcareFile = /** @class */ (function () {
    function UploadcareFile(fileInfo, _a) {
        var baseCDN = _a.baseCDN, defaultEffects = _a.defaultEffects, fileName = _a.fileName;
        this.name = null;
        this.size = null;
        this.isStored = null;
        this.isImage = null;
        this.mimeType = null;
        this.cdnUrl = null;
        this.cdnUrlModifiers = null;
        this.originalUrl = null;
        this.originalFilename = null;
        this.imageInfo = null;
        this.videoInfo = null;
        var uuid = fileInfo.uuid, s3Bucket = fileInfo.s3Bucket;
        var urlBase = s3Bucket
            ? "https://" + s3Bucket + ".s3.amazonaws.com/" + uuid + "/" + fileInfo.filename
            : baseCDN + "/" + uuid + "/";
        var cdnUrlModifiers = defaultEffects ? "-/" + defaultEffects : null;
        var cdnUrl = "" + urlBase + (cdnUrlModifiers || '');
        var originalUrl = uuid ? urlBase : null;
        this.uuid = uuid;
        this.name = fileName || fileInfo.filename;
        this.size = fileInfo.size;
        this.isStored = fileInfo.isStored;
        this.isImage = fileInfo.isImage;
        this.mimeType = fileInfo.mimeType;
        this.cdnUrl = cdnUrl;
        this.cdnUrlModifiers = cdnUrlModifiers;
        this.originalUrl = originalUrl;
        this.originalFilename = fileInfo.originalFilename;
        this.imageInfo = camelizeKeys(fileInfo.imageInfo);
        this.videoInfo = camelizeKeys(fileInfo.videoInfo);
    }
    return UploadcareFile;
}());

var DEFAULT_INTERVAL = 500;
var poll = function (_a) {
    var check = _a.check, _b = _a.interval, interval = _b === void 0 ? DEFAULT_INTERVAL : _b, signal = _a.signal;
    return new Promise(function (resolve, reject) {
        var timeoutId;
        onCancel(signal, function () {
            timeoutId && clearTimeout(timeoutId);
            reject(cancelError('Poll cancelled'));
        });
        var tick = function () {
            try {
                Promise.resolve(check(signal))
                    .then(function (result) {
                    if (result) {
                        resolve(result);
                    }
                    else {
                        timeoutId = setTimeout(tick, interval);
                    }
                })
                    .catch(function (error) { return reject(error); });
            }
            catch (error) {
                reject(error);
            }
        };
        timeoutId = setTimeout(tick, 0);
    });
};

function isReadyPoll(_a) {
    var file = _a.file, publicKey = _a.publicKey, baseURL = _a.baseURL, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, signal = _a.signal, onProgress = _a.onProgress;
    return poll({
        check: function (signal) {
            return info(file, {
                publicKey: publicKey,
                baseURL: baseURL,
                signal: signal,
                source: source,
                integration: integration,
                userAgent: userAgent,
                retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
            }).then(function (response) {
                if (response.isReady) {
                    return response;
                }
                onProgress && onProgress({ value: 1 });
                return false;
            });
        },
        signal: signal
    });
}

var uploadFromObject = function (file, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, baseURL = _a.baseURL, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, baseCDN = _a.baseCDN;
    return base(file, {
        publicKey: publicKey,
        fileName: fileName,
        baseURL: baseURL,
        secureSignature: secureSignature,
        secureExpire: secureExpire,
        store: store,
        signal: signal,
        onProgress: onProgress,
        source: source,
        integration: integration,
        userAgent: userAgent,
        retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
    })
        .then(function (_a) {
        var file = _a.file;
        return isReadyPoll({
            file: file,
            publicKey: publicKey,
            baseURL: baseURL,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            onProgress: onProgress,
            signal: signal
        });
    })
        .then(function (fileInfo) { return new UploadcareFile(fileInfo, { baseCDN: baseCDN }); });
};

/*globals self, window */

/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined;

var race = function (fns, _a) {
    var signal = (_a === void 0 ? {} : _a).signal;
    var lastError = null;
    var winnerIndex = null;
    var controllers = fns.map(function () { return new AbortController(); });
    var createStopRaceCallback = function (i) { return function () {
        winnerIndex = i;
        controllers.forEach(function (controller, index) { return index !== i && controller.abort(); });
    }; };
    onCancel(signal, function () {
        controllers.forEach(function (controller) { return controller.abort(); });
    });
    return Promise.all(fns.map(function (fn, i) {
        var stopRace = createStopRaceCallback(i);
        return Promise.resolve()
            .then(function () { return fn({ stopRace: stopRace, signal: controllers[i].signal }); })
            .then(function (result) {
            stopRace();
            return result;
        })
            .catch(function (error) {
            lastError = error;
            return null;
        });
    })).then(function (results) {
        if (winnerIndex === null) {
            throw lastError;
        }
        else {
            return results[winnerIndex];
        }
    });
};

var WebSocket = window.WebSocket;

var Events = /** @class */ (function () {
    function Events() {
        this.events = Object.create({});
    }
    Events.prototype.emit = function (event, data) {
        var _a;
        (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.forEach(function (fn) { return fn(data); });
    };
    Events.prototype.on = function (event, callback) {
        this.events[event] = this.events[event] || [];
        this.events[event].push(callback);
    };
    Events.prototype.off = function (event, callback) {
        if (callback) {
            this.events[event] = this.events[event].filter(function (fn) { return fn !== callback; });
        }
        else {
            this.events[event] = [];
        }
    };
    return Events;
}());

var response = function (type, data) {
    if (type === 'success') {
        return __assign({ status: Status.Success }, data);
    }
    if (type === 'progress') {
        return __assign({ status: Status.Progress }, data);
    }
    return __assign({ status: Status.Error }, data);
};
var Pusher = /** @class */ (function () {
    function Pusher(pusherKey, disconnectTime) {
        if (disconnectTime === void 0) { disconnectTime = 30000; }
        this.ws = undefined;
        this.queue = [];
        this.isConnected = false;
        this.subscribers = 0;
        this.emmitter = new Events();
        this.disconnectTimeoutId = null;
        this.key = pusherKey;
        this.disconnectTime = disconnectTime;
    }
    Pusher.prototype.connect = function () {
        var _this = this;
        this.disconnectTimeoutId && clearTimeout(this.disconnectTimeoutId);
        if (!this.isConnected && !this.ws) {
            var pusherUrl = "wss://ws.pusherapp.com/app/" + this.key + "?protocol=5&client=js&version=1.12.2";
            this.ws = new WebSocket(pusherUrl);
            this.ws.addEventListener('error', function (error) {
                _this.emmitter.emit('error', new Error(error.message));
            });
            this.emmitter.on('connected', function () {
                _this.isConnected = true;
                _this.queue.forEach(function (message) { return _this.send(message.event, message.data); });
                _this.queue = [];
            });
            this.ws.addEventListener('message', function (e) {
                var data = JSON.parse(e.data.toString());
                switch (data.event) {
                    case 'pusher:connection_established': {
                        _this.emmitter.emit('connected', undefined);
                        break;
                    }
                    case 'pusher:ping': {
                        _this.send('pusher:pong', {});
                        break;
                    }
                    case 'progress':
                    case 'success':
                    case 'fail': {
                        _this.emmitter.emit(data.channel, response(data.event, JSON.parse(data.data)));
                    }
                }
            });
        }
    };
    Pusher.prototype.disconnect = function () {
        var _this = this;
        var actualDisconect = function () {
            var _a;
            (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.close();
            _this.ws = undefined;
            _this.isConnected = false;
        };
        if (this.disconnectTime) {
            this.disconnectTimeoutId = setTimeout(function () {
                actualDisconect();
            }, this.disconnectTime);
        }
        else {
            actualDisconect();
        }
    };
    Pusher.prototype.send = function (event, data) {
        var _a;
        var str = JSON.stringify({ event: event, data: data });
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(str);
    };
    Pusher.prototype.subscribe = function (token, handler) {
        this.subscribers += 1;
        this.connect();
        var channel = "task-status-" + token;
        var message = {
            event: 'pusher:subscribe',
            data: { channel: channel }
        };
        this.emmitter.on(channel, handler);
        if (this.isConnected) {
            this.send(message.event, message.data);
        }
        else {
            this.queue.push(message);
        }
    };
    Pusher.prototype.unsubscribe = function (token) {
        this.subscribers -= 1;
        var channel = "task-status-" + token;
        var message = {
            event: 'pusher:unsubscribe',
            data: { channel: channel }
        };
        this.emmitter.off(channel);
        if (this.isConnected) {
            this.send(message.event, message.data);
        }
        else {
            this.queue = this.queue.filter(function (msg) { return msg.data.channel !== channel; });
        }
        if (this.subscribers === 0) {
            this.disconnect();
        }
    };
    Pusher.prototype.onError = function (callback) {
        var _this = this;
        this.emmitter.on('error', callback);
        return function () { return _this.emmitter.off('error', callback); };
    };
    return Pusher;
}());
var pusher = null;
var getPusher = function (key) {
    if (!pusher) {
        // no timeout for nodeJS and 30000 ms for browser
        var disconectTimeout = typeof window === 'undefined' ? 0 : 30000;
        pusher = new Pusher(key, disconectTimeout);
    }
    return pusher;
};
var preconnect = function (key) {
    getPusher(key).connect();
};

function pollStrategy(_a) {
    var token = _a.token, publicKey = _a.publicKey, baseURL = _a.baseURL, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, onProgress = _a.onProgress, signal = _a.signal;
    return poll({
        check: function (signal) {
            return fromUrlStatus(token, {
                publicKey: publicKey,
                baseURL: baseURL,
                integration: integration,
                userAgent: userAgent,
                retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                signal: signal
            }).then(function (response) {
                switch (response.status) {
                    case Status.Error: {
                        return new UploadClientError(response.error, response.errorCode);
                    }
                    case Status.Waiting: {
                        return false;
                    }
                    case Status.Unknown: {
                        return new UploadClientError("Token \"" + token + "\" was not found.");
                    }
                    case Status.Progress: {
                        if (onProgress)
                            onProgress({ value: response.done / response.total });
                        return false;
                    }
                    case Status.Success: {
                        if (onProgress)
                            onProgress({ value: response.done / response.total });
                        return response;
                    }
                    default: {
                        throw new Error('Unknown status');
                    }
                }
            });
        },
        signal: signal
    });
}
var pushStrategy = function (_a) {
    var token = _a.token, pusherKey = _a.pusherKey, signal = _a.signal, onProgress = _a.onProgress;
    return new Promise(function (resolve, reject) {
        var pusher = getPusher(pusherKey);
        var unsubErrorHandler = pusher.onError(reject);
        var destroy = function () {
            unsubErrorHandler();
            pusher.unsubscribe(token);
        };
        onCancel(signal, function () {
            destroy();
            reject(cancelError('pusher cancelled'));
        });
        pusher.subscribe(token, function (result) {
            switch (result.status) {
                case Status.Progress: {
                    if (onProgress) {
                        onProgress({ value: result.done / result.total });
                    }
                    break;
                }
                case Status.Success: {
                    destroy();
                    if (onProgress)
                        onProgress({ value: result.done / result.total });
                    resolve(result);
                    break;
                }
                case Status.Error: {
                    destroy();
                    reject(new UploadClientError(result.msg, result.error_code));
                }
            }
        });
    });
};
var uploadFromUrl = function (sourceUrl, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, baseURL = _a.baseURL, baseCDN = _a.baseCDN, checkForUrlDuplicates = _a.checkForUrlDuplicates, saveUrlForRecurrentUploads = _a.saveUrlForRecurrentUploads, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, _b = _a.pusherKey, pusherKey = _b === void 0 ? defaultSettings.pusherKey : _b;
    return Promise.resolve(preconnect(pusherKey))
        .then(function () {
        return fromUrl(sourceUrl, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            checkForUrlDuplicates: checkForUrlDuplicates,
            saveUrlForRecurrentUploads: saveUrlForRecurrentUploads,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            signal: signal,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
        });
    })
        .catch(function (error) {
        var pusher = getPusher(pusherKey);
        pusher === null || pusher === void 0 ? void 0 : pusher.disconnect();
        return Promise.reject(error);
    })
        .then(function (urlResponse) {
        if (urlResponse.type === TypeEnum.FileInfo) {
            return urlResponse;
        }
        else {
            return race([
                function (_a) {
                    var signal = _a.signal;
                    return pollStrategy({
                        token: urlResponse.token,
                        publicKey: publicKey,
                        baseURL: baseURL,
                        integration: integration,
                        userAgent: userAgent,
                        retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                        onProgress: onProgress,
                        signal: signal
                    });
                },
                function (_a) {
                    var signal = _a.signal;
                    return pushStrategy({
                        token: urlResponse.token,
                        pusherKey: pusherKey,
                        signal: signal,
                        onProgress: onProgress
                    });
                }
            ], { signal: signal });
        }
    })
        .then(function (result) {
        if (result instanceof UploadClientError)
            throw result;
        return result;
    })
        .then(function (result) {
        return isReadyPoll({
            file: result.uuid,
            publicKey: publicKey,
            baseURL: baseURL,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            onProgress: onProgress,
            signal: signal
        });
    })
        .then(function (fileInfo) { return new UploadcareFile(fileInfo, { baseCDN: baseCDN }); });
};

var uploadFromUploaded = function (uuid, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, baseURL = _a.baseURL, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, baseCDN = _a.baseCDN;
    return info(uuid, {
        publicKey: publicKey,
        baseURL: baseURL,
        signal: signal,
        source: source,
        integration: integration,
        userAgent: userAgent,
        retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
    })
        .then(function (fileInfo) { return new UploadcareFile(fileInfo, { baseCDN: baseCDN, fileName: fileName }); })
        .then(function (result) {
        // hack for node ¯\_(ツ)_/¯
        if (onProgress)
            onProgress({ value: 1 });
        return result;
    });
};

/**
 * FileData type guard.
 */
var isFileData = function (data) {
    return (data !== undefined &&
        ((typeof Blob !== 'undefined' && data instanceof Blob) ||
            (typeof File !== 'undefined' && data instanceof File) ||
            (typeof Buffer !== 'undefined' && data instanceof Buffer)));
};
/**
 * Uuid type guard.
 */
var isUuid = function (data) {
    var UUID_REGEX = '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}';
    var regExp = new RegExp(UUID_REGEX);
    return !isFileData(data) && regExp.test(data);
};
/**
 * Url type guard.
 *
 * @param {NodeFile | BrowserFile | Url | Uuid} data
 */
var isUrl = function (data) {
    var URL_REGEX = '^(?:\\w+:)?\\/\\/([^\\s\\.]+\\.\\S{2}|localhost[\\:?\\d]*)\\S*$';
    var regExp = new RegExp(URL_REGEX);
    return !isFileData(data) && regExp.test(data);
};

/**
 * Get file size.
 */
var getFileSize = function (file) {
    return file.length || file.size;
};
/**
 * Check if FileData is multipart data.
 */
var isMultipart = function (fileSize, multipartMinFileSize) {
    if (multipartMinFileSize === void 0) { multipartMinFileSize = defaultSettings.multipartMinFileSize; }
    return fileSize >= multipartMinFileSize;
};

var sliceChunk = function (file, index, fileSize, chunkSize) {
    var start = chunkSize * index;
    var end = Math.min(start + chunkSize, fileSize);
    return file.slice(start, end);
};

function prepareChunks(file, fileSize, chunkSize) {
    return function (index) {
        return sliceChunk(file, index, fileSize, chunkSize);
    };
}

var runWithConcurrency = function (concurrency, tasks) {
    return new Promise(function (resolve, reject) {
        var results = [];
        var rejected = false;
        var settled = tasks.length;
        var forRun = __spreadArrays(tasks);
        var run = function () {
            var index = tasks.length - forRun.length;
            var next = forRun.shift();
            if (next) {
                next()
                    .then(function (result) {
                    if (rejected)
                        return;
                    results[index] = result;
                    settled -= 1;
                    if (settled) {
                        run();
                    }
                    else {
                        resolve(results);
                    }
                })
                    .catch(function (error) {
                    rejected = true;
                    reject(error);
                });
            }
        };
        for (var i = 0; i < concurrency; i++) {
            run();
        }
    });
};

var uploadPartWithRetry = function (chunk, url, _a) {
    var publicKey = _a.publicKey, onProgress = _a.onProgress, signal = _a.signal, integration = _a.integration, multipartMaxAttempts = _a.multipartMaxAttempts;
    return retrier(function (_a) {
        var attempt = _a.attempt, retry = _a.retry;
        return multipartUpload(chunk, url, {
            publicKey: publicKey,
            onProgress: onProgress,
            signal: signal,
            integration: integration
        }).catch(function (error) {
            if (attempt < multipartMaxAttempts) {
                return retry();
            }
            throw error;
        });
    });
};
var uploadMultipart = function (file, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, fileSize = _a.fileSize, baseURL = _a.baseURL, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, contentType = _a.contentType, _b = _a.multipartChunkSize, multipartChunkSize = _b === void 0 ? defaultSettings.multipartChunkSize : _b, _c = _a.maxConcurrentRequests, maxConcurrentRequests = _c === void 0 ? defaultSettings.maxConcurrentRequests : _c, _d = _a.multipartMaxAttempts, multipartMaxAttempts = _d === void 0 ? defaultSettings.multipartMaxAttempts : _d, baseCDN = _a.baseCDN;
    var size = fileSize || getFileSize(file);
    var progressValues;
    var createProgressHandler = function (size, index) {
        if (!onProgress)
            return;
        if (!progressValues) {
            progressValues = Array(size).fill(0);
        }
        var sum = function (values) {
            return values.reduce(function (sum, next) { return sum + next; }, 0);
        };
        return function (_a) {
            var value = _a.value;
            progressValues[index] = value;
            onProgress({ value: sum(progressValues) / size });
        };
    };
    return multipartStart(size, {
        publicKey: publicKey,
        contentType: contentType,
        fileName: fileName !== null && fileName !== void 0 ? fileName : file.name,
        baseURL: baseURL,
        secureSignature: secureSignature,
        secureExpire: secureExpire,
        store: store,
        signal: signal,
        source: source,
        integration: integration,
        userAgent: userAgent,
        retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
    })
        .then(function (_a) {
        var uuid = _a.uuid, parts = _a.parts;
        var getChunk = prepareChunks(file, size, multipartChunkSize);
        return Promise.all([
            uuid,
            runWithConcurrency(maxConcurrentRequests, parts.map(function (url, index) { return function () {
                return uploadPartWithRetry(getChunk(index), url, {
                    publicKey: publicKey,
                    onProgress: createProgressHandler(parts.length, index),
                    signal: signal,
                    integration: integration,
                    multipartMaxAttempts: multipartMaxAttempts
                });
            }; }))
        ]);
    })
        .then(function (_a) {
        var uuid = _a[0];
        return multipartComplete(uuid, {
            publicKey: publicKey,
            baseURL: baseURL,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
        });
    })
        .then(function (fileInfo) {
        if (fileInfo.isReady) {
            return fileInfo;
        }
        else {
            return isReadyPoll({
                file: fileInfo.uuid,
                publicKey: publicKey,
                baseURL: baseURL,
                source: source,
                integration: integration,
                userAgent: userAgent,
                retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                onProgress: onProgress,
                signal: signal
            });
        }
    })
        .then(function (fileInfo) { return new UploadcareFile(fileInfo, { baseCDN: baseCDN }); });
};

/**
 * Uploads file from provided data.
 */
function uploadFile(data, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, contentType = _a.contentType, multipartChunkSize = _a.multipartChunkSize, multipartMaxAttempts = _a.multipartMaxAttempts, maxConcurrentRequests = _a.maxConcurrentRequests, _c = _a.baseCDN, baseCDN = _c === void 0 ? defaultSettings.baseCDN : _c, checkForUrlDuplicates = _a.checkForUrlDuplicates, saveUrlForRecurrentUploads = _a.saveUrlForRecurrentUploads, pusherKey = _a.pusherKey;
    if (isFileData(data)) {
        var fileSize = getFileSize(data);
        if (isMultipart(fileSize)) {
            return uploadMultipart(data, {
                publicKey: publicKey,
                contentType: contentType,
                multipartChunkSize: multipartChunkSize,
                multipartMaxAttempts: multipartMaxAttempts,
                fileName: fileName,
                baseURL: baseURL,
                secureSignature: secureSignature,
                secureExpire: secureExpire,
                store: store,
                signal: signal,
                onProgress: onProgress,
                source: source,
                integration: integration,
                userAgent: userAgent,
                maxConcurrentRequests: maxConcurrentRequests,
                retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                baseCDN: baseCDN
            });
        }
        return uploadFromObject(data, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            signal: signal,
            onProgress: onProgress,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            baseCDN: baseCDN
        });
    }
    if (isUrl(data)) {
        return uploadFromUrl(data, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            baseCDN: baseCDN,
            checkForUrlDuplicates: checkForUrlDuplicates,
            saveUrlForRecurrentUploads: saveUrlForRecurrentUploads,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            signal: signal,
            onProgress: onProgress,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            pusherKey: pusherKey
        });
    }
    if (isUuid(data)) {
        return uploadFromUploaded(data, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            signal: signal,
            onProgress: onProgress,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            baseCDN: baseCDN
        });
    }
    throw new TypeError("File uploading from \"" + data + "\" is not supported");
}

var UploadcareGroup = /** @class */ (function () {
    function UploadcareGroup(groupInfo, files) {
        this.storedAt = null;
        this.uuid = groupInfo.id;
        this.filesCount = groupInfo.filesCount;
        this.totalSize = Object.values(groupInfo.files).reduce(function (acc, file) { return acc + file.size; }, 0);
        this.isStored = !!groupInfo.datetimeStored;
        this.isImage = !!Object.values(groupInfo.files).filter(function (file) { return file.isImage; }).length;
        this.cdnUrl = groupInfo.cdnUrl;
        this.files = files;
        this.createdAt = groupInfo.datetimeCreated;
        this.storedAt = groupInfo.datetimeStored;
    }
    return UploadcareGroup;
}());

/**
 * FileData type guard.
 */
var isFileDataArray = function (data) {
    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
        var item = data_1[_i];
        if (!isFileData(item)) {
            return false;
        }
    }
    return true;
};
/**
 * Uuid type guard.
 */
var isUuidArray = function (data) {
    for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
        var item = data_2[_i];
        if (!isUuid(item)) {
            return false;
        }
    }
    return true;
};
/**
 * Url type guard.
 */
var isUrlArray = function (data) {
    for (var _i = 0, data_3 = data; _i < data_3.length; _i++) {
        var item = data_3[_i];
        if (!isUrl(item)) {
            return false;
        }
    }
    return true;
};

function uploadFileGroup(data, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings.baseURL : _b, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, signal = _a.signal, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, userAgent = _a.userAgent, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, contentType = _a.contentType, _c = _a.multipartChunkSize, multipartChunkSize = _c === void 0 ? defaultSettings.multipartChunkSize : _c, _d = _a.baseCDN, baseCDN = _d === void 0 ? defaultSettings.baseCDN : _d, jsonpCallback = _a.jsonpCallback, defaultEffects = _a.defaultEffects;
    if (!isFileDataArray(data) && !isUrlArray(data) && !isUuidArray(data)) {
        throw new TypeError("Group uploading from \"" + data + "\" is not supported");
    }
    var progressValues;
    var filesCount = data.length;
    var createProgressHandler = function (size, index) {
        if (!onProgress)
            return;
        if (!progressValues) {
            progressValues = Array(size).fill(0);
        }
        var normalize = function (values) {
            return values.reduce(function (sum, next) { return sum + next; }) / size;
        };
        return function (_a) {
            var value = _a.value;
            progressValues[index] = value;
            onProgress({ value: normalize(progressValues) });
        };
    };
    return Promise.all(data.map(function (file, index) {
        return uploadFile(file, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            signal: signal,
            onProgress: createProgressHandler(filesCount, index),
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            contentType: contentType,
            multipartChunkSize: multipartChunkSize,
            baseCDN: baseCDN
        });
    })).then(function (files) {
        var uuids = files.map(function (file) { return file.uuid; });
        var addDefaultEffects = function (file) {
            var cdnUrlModifiers = defaultEffects ? "-/" + defaultEffects : null;
            var cdnUrl = "" + file.urlBase + (cdnUrlModifiers || '');
            return __assign(__assign({}, file), { cdnUrlModifiers: cdnUrlModifiers,
                cdnUrl: cdnUrl });
        };
        var filesInGroup = defaultEffects ? files.map(addDefaultEffects) : files;
        return group(uuids, {
            publicKey: publicKey,
            baseURL: baseURL,
            jsonpCallback: jsonpCallback,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            signal: signal,
            source: source,
            integration: integration,
            userAgent: userAgent,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
        }).then(function (groupInfo) { return new UploadcareGroup(groupInfo, filesInGroup); });
    });
}

/**
 * Populate options with settings.
 */
var populateOptionsWithSettings = function (options, settings) { return (__assign(__assign({}, settings), options)); };
var UploadClient = /** @class */ (function () {
    function UploadClient(settings) {
        this.settings = Object.assign({}, defaultSettings, settings);
    }
    UploadClient.prototype.updateSettings = function (newSettings) {
        this.settings = Object.assign(this.settings, newSettings);
    };
    UploadClient.prototype.getSettings = function () {
        return this.settings;
    };
    UploadClient.prototype.base = function (file, options) {
        var settings = this.getSettings();
        return base(file, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.info = function (uuid, options) {
        var settings = this.getSettings();
        return info(uuid, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.fromUrl = function (sourceUrl, options) {
        var settings = this.getSettings();
        return fromUrl(sourceUrl, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.fromUrlStatus = function (token, options) {
        var settings = this.getSettings();
        return fromUrlStatus(token, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.group = function (uuids, options) {
        var settings = this.getSettings();
        return group(uuids, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.groupInfo = function (id, options) {
        var settings = this.getSettings();
        return groupInfo(id, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.multipartStart = function (size, options) {
        var settings = this.getSettings();
        return multipartStart(size, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.multipartUpload = function (part, url, options) {
        var settings = this.getSettings();
        return multipartUpload(part, url, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.multipartComplete = function (uuid, options) {
        var settings = this.getSettings();
        return multipartComplete(uuid, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.uploadFile = function (data, options) {
        var settings = this.getSettings();
        return uploadFile(data, populateOptionsWithSettings(options, settings));
    };
    UploadClient.prototype.uploadFileGroup = function (data, options) {
        var settings = this.getSettings();
        return uploadFileGroup(data, populateOptionsWithSettings(options, settings));
    };
    return UploadClient;
}());

exports.AbortController = AbortController;
exports.UploadClient = UploadClient;
exports.UploadClientError = UploadClientError;
exports.UploadcareFile = UploadcareFile;
exports.UploadcareGroup = UploadcareGroup;
exports.base = base;
exports.fromUrl = fromUrl;
exports.fromUrlStatus = fromUrlStatus;
exports.group = group;
exports.groupInfo = groupInfo;
exports.info = info;
exports.multipartComplete = multipartComplete;
exports.multipartStart = multipartStart;
exports.multipartUpload = multipartUpload;
exports.uploadBase = uploadFromObject;
exports.uploadFile = uploadFile;
exports.uploadFileGroup = uploadFileGroup;
exports.uploadFromUploaded = uploadFromUploaded;
exports.uploadFromUrl = uploadFromUrl;
exports.uploadMultipart = uploadMultipart;
