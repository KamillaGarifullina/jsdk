export class Data {
	static warn(actionName: string, prop: string): void;
	static registerLocalCtx(schema: {
		[x: string]: any;
	}): Data;
	static registerNamedCtx(ctxName: string, schema: {
		[x: string]: any;
	}): Data;
	static clearNamedCtx(ctxName: string): void;
	static getNamedCtx(ctxName: string, notify?: boolean): Data;
	constructor(src: {
		name?: string;
		schema: {
			[x: string]: any;
		};
	});
	uid: symbol;
	name: string;
	store: {
		[x: string]: any;
	};
	private _storeIsProxy;
	callbackMap: any;
	read(prop: string): any;
	has(prop: string): boolean;
	add(prop: string, val: unknown, rewrite?: boolean): void;
	pub<T>(prop: string, val: T): void;
	multiPub(updObj: {
		[x: string]: any;
	}): void;
	notify(prop: string): void;
	sub(prop: string, callback: Function, init?: boolean): {
		remove: () => void;
		callback: Function;
	};
	remove(): void;
}
export namespace Data {
	const globalStore: any;
}
export class BaseComponent extends HTMLElement {
	static template: string;
	private static __parseProp;
	static reg(tagName?: string, isAlias?: boolean): void;
	static get is(): string;
	static bindAttributes(desc: {
		[x: string]: string;
	}): void;
	static set shadowStyles(arg: string);
	initCallback(): void;
	private __initCallback;
	private __initialized;
	render(template?: string | DocumentFragment, shadow?: boolean): void;
	addTemplateProcessor<T extends BaseComponent>(processorFn: (fr: DocumentFragment, fnCtx: T) => void): void;
	init$: {
		[x: string]: unknown;
	};
	tplProcessors: Set<(fr: DocumentFragment, fnCtx: unknown) => void>;
	ref: {
		[x: string]: any;
	};
	allSubs: Set<any>;
	pauseRender: boolean;
	renderShadow: boolean;
	readyToDestroy: boolean;
	get autoCtxName(): string;
	private __autoCtxName;
	get cssCtxName(): string;
	get ctxName(): string;
	get localCtx(): Data;
	private __localCtx;
	get nodeCtx(): Data;
	sub<T_1>(prop: string, handler: (value: T_1) => void): void;
	notify(prop: string): void;
	has(prop: string): boolean;
	add<T_2>(prop: string, val: T_2): void;
	add$(obj: {
		[x: string]: any;
	}): void;
	get $(): {
		[x: string]: any;
	};
	private __stateProxy;
	set$(kvObj: {
		[x: string]: any;
	}): void;
	private __initDataCtx;
	__dataCtxInitialized: boolean;
	connectedCallback(): void;
	initChildren: ChildNode[];
	connectedOnce: boolean;
	destroyCallback(): void;
	disconnectedCallback(): void;
	private __disconnectTimeout;
	attributeChangedCallback(name: any, oldVal: any, newVal: any): void;
	getCssData(propName: string, silentCheck?: boolean): any;
	private __cssDataCache;
	private __computedStyle;
	bindCssData(propName: string, external?: boolean): string;
	dropCssDataCache(): void;
	defineAccessor(propName: string, handler?: Function, isAsync?: boolean): void;
}
export class TypedData {
	constructor(typedSchema: {
		[x: string]: {
			type: any;
			value: any;
		};
	}, ctxName?: string);
	private __typedSchema;
	private __ctxId;
	private __schema;
	private __data;
	get uid(): string;
	setValue(prop: string, value: any): void;
	setMultipleValues(updObj: {
		[x: string]: any;
	}): void;
	getValue(prop: string): any;
	subscribe(prop: string, handler: (newVal: any) => void): {
		remove: () => void;
		callback: Function;
	};
	remove(): void;
}
export class TypedCollection {
	constructor(options: {
		typedSchema: {
			[x: string]: {
				type: any;
				value: any;
			};
		};
		watchList?: string[];
		handler?: (list: string[]) => void;
		ctxName?: string;
	});
	private __typedSchema;
	private __ctxId;
	private __data;
	private __watchList;
	private __handler;
	private __subsMap;
	private __observers;
	private __items;
	private __notifyObservers;
	private __observeTimeout;
	notify(): void;
	private __notifyTimeout;
	add(init: {
		[x: string]: any;
	}): any;
	read(id: string): TypedData;
	readProp(id: string, propName: string): any;
	publishProp<T>(id: string, propName: string, value: T): void;
	remove(id: string): void;
	clearAll(): void;
	observe(handler: Function): void;
	unobserve(handler: Function): void;
	findItems(checkFn: (item: TypedData) => boolean): string[];
	items(): string[];
	destroy(): void;
}
export class AppRouter {
	private static _print;
	static setDefaultTitle(title: string): void;
	static setRoutingMap(map: {
		[x: string]: {};
	}): void;
	static set routingEventName(arg: string);
	static get routingEventName(): string;
	static readAddressBar(): {
		route: any;
		options: {};
	};
	static notify(): void;
	static reflect(route: string, options?: {
		[x: string]: any;
	}): void;
	static applyRoute(route: string, options?: {
		[x: string]: any;
	}): void;
	static setSeparator(char: string): void;
	static get separator(): string;
	static createRouterData(ctxName: string, routingMap: {
		[x: string]: {};
	}): Data;
}
export namespace AppRouter {
	const defaultTitle: string;
	const defaultRoute: string;
	const errorRoute: string;
	const __routingEventName: string;
	const _separator: string;
	const appMap: any;
}
export class UID {
	static generate(pattern?: string): string;
}
export class IDB {
	static get readyEventName(): string;
	static open(dbName?: string, storeName?: string): DbInstance;
	private static _reg;
	static clear(dbName: string): void;
}
declare class DbInstance {
	constructor(dbName: string, storeName: string);
	private _notifyWhenReady;
	private get _updEventName();
	private _getUpdateEvent;
	private _notifySubscribers;
	name: string;
	storeName: string;
	version: number;
	request: IDBOpenDBRequest;
	db: any;
	objStore: any;
	private _subscribtionsMap;
	private _updateHandler;
	private _localUpdateHandler;
	read(key: string): Promise<any>;
	write(key: string, value: any, silent?: boolean): Promise<any>;
	delete(key: string, silent?: boolean): Promise<any>;
	getAll(): Promise<any>;
	subscribe(key: string, callback: (val: any) => void): {
		remove: () => void;
	};
	stop(): void;
}
export function applyStyles<T extends HTMLElement>(el: T, styleMap: StyleMap): void;
export function applyAttributes<T extends HTMLElement>(el: T, attrMap: AttrMap): void;
export function create(desc?: ElementDescriptor): any;
export type StyleMap = {
	[x: string]: string | number | boolean;
};
export type AttrMap = {
	[x: string]: string | number | boolean;
};
export type PropMap = {
	[x: string]: any;
};
export type ElementDescriptor = {
	tag?: string;
	attributes?: AttrMap;
	styles?: StyleMap;
	properties?: PropMap;
	processors?: Function[];
	children?: ElementDescriptor[];
};

export {};
